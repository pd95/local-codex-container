#!/usr/bin/env bash
set -euo pipefail

CONTAINER_CMD="${CONTAINER_CMD:-container}"
DEFAULT_IMAGE="codex"
DEFAULT_NAME_PREFIX="codex-"
AUTH_NAME_PREFIX="codex-openai-auth-"
DEFAULT_SHELL="${CODEX_SHELL:-bash}"
DEFAULT_CODEX_PROFILE="gpt-oss"
DEFAULT_CODEX_CMD=(codex)
SETPRIV_ARGS=(setpriv --inh-caps=-all --ambient-caps=-all --bounding-set=-all --no-new-privs --)

resolve_script_path() {
  local path="$1"
  while [ -L "$path" ]; do
    local target
    target="$(readlink "$path")"
    if [[ "$target" != /* ]]; then
      path="$(CDPATH= cd -- "$(dirname -- "$path")" && pwd)/$target"
    else
      path="$target"
    fi
  done
  echo "$path"
}

SCRIPT_PATH="$(resolve_script_path "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(CDPATH= cd -- "$(dirname -- "$SCRIPT_PATH")" && pwd)"
KEYCHAIN_SCRIPT="$SCRIPT_DIR/codex-auth-keychain.sh"

die() {
  echo "Error: $*" >&2
  exit 1
}

warn() {
  echo "Warning: $*" >&2
}

require_container() {
  command -v "$CONTAINER_CMD" >/dev/null 2>&1 || die "Missing '$CONTAINER_CMD' command"
}

python_exec() {
  local python_cmd=""
  if command -v python3 >/dev/null 2>&1; then
    python_cmd="python3"
  elif command -v python >/dev/null 2>&1; then
    python_cmd="python"
  else
    die "Missing python (python3 or python)"
  fi
  "$python_cmd" -c "$1"
}

container_list_all() {
  "$CONTAINER_CMD" ls -a 2>/dev/null || true
}

container_list_running() {
  "$CONTAINER_CMD" ls 2>/dev/null || true
}

container_exists() {
  container_list_all | grep -q -E "(^|[[:space:]])$1([[:space:]]|$)"
}

container_running() {
  container_list_running | grep -q -E "(^|[[:space:]])$1([[:space:]]|$)"
}

container_mount_mode() {
  local script
  script="$(cat <<'PY'
import json
import sys

try:
    data = json.loads(sys.stdin.read())
except Exception:
    print("unknown")
    sys.exit(0)

if isinstance(data, list) and data:
    data = data[0]

config = data.get("configuration") or data
mounts = config.get("mounts") or []

mode = "unknown"
for mount in mounts:
    target = mount.get("destination") or mount.get("dst") or ""
    if target != "/workdir":
        continue
    opts = mount.get("options") or []
    if isinstance(opts, str):
        opts = [opts]
    mode = "ro" if "ro" in opts else "rw"
    break

print(mode)
PY
)"
  python_exec "$script" || echo "unknown"
}

validate_mount_mode() {
  local name="$1"
  local read_only="$2"
  local mode
  mode="$("$CONTAINER_CMD" inspect "$name" 2>/dev/null | container_mount_mode)"
  if [ "$read_only" -eq 1 ]; then
    if [ "$mode" = "rw" ]; then
      die "Container already exists: $name (created with writable mount; remove it to recreate read-only, or run without --read-only)"
    fi
    if [ "$mode" = "unknown" ]; then
      warn "Unable to verify mount mode for $name; proceeding"
    fi
  else
    if [ "$mode" = "ro" ]; then
      die "Container already exists: $name (created with read-only mount; remove it to recreate writable, or use --read-only)"
    fi
    if [ "$mode" = "unknown" ]; then
      warn "Unable to verify mount mode for $name; proceeding"
    fi
  fi
}

image_list() {
  "$CONTAINER_CMD" image ls 2>/dev/null || "$CONTAINER_CMD" images 2>/dev/null || true
}

image_exists() {
  image_list | grep -q -E "(^|[[:space:]])$1([[:space:]]|$)"
}

default_name() {
  local prefix="$1"
  echo "${prefix}$(sanitize_container_name "$(basename "$PWD")")"
}

sanitize_container_name() {
  local raw="$1"
  local sanitized
  sanitized="$(printf '%s' "$raw" | tr -cs 'A-Za-z0-9_.-' '-')"
  sanitized="${sanitized#-}"
  sanitized="${sanitized%-}"
  if [ -z "$sanitized" ]; then
    sanitized="workdir"
  fi
  echo "$sanitized"
}

usage() {
  cat <<'EOF'
Usage: codexctl <command> [options]

Commands:
  build      Build Codex images
  run        Create/start a container for the current directory
  auth       Run OpenAI device auth flow and store in Keychain
  exec       Exec into a running container (default: bash)
  su-exec    Exec into a running container as root (default: bash)
  start      Start a container
  stop       Stop a running container
  restart    Restart a container
  rm         Remove a container
  ls         List containers

Run "codexctl <command> --help" for command-specific options.
EOF
}

usage_build() {
  cat <<'EOF'
Usage: codexctl build [--image NAME] [--rebuild] [--pull-base] [--refresh-base]

Options:
  --image NAME  One of: codex, codex-python, codex-swift, codex-office (default: all)
  --rebuild     Rebuild images even if they already exist (disables build cache)
  --pull-base     Pull the base image before building
  --refresh-base  Remove the base image first so it is re-fetched
EOF
}

usage_run() {
  cat <<'EOF'
Usage: codexctl run [options]

Options:
  --name NAME     Container name (default: codex-<dir>)
  --image NAME    Image to use (default: codex)
  --openai        Use OpenAI mode (device auth)
  --auth          Force OpenAI login flow
  --temp          Create a throwaway container (auto-removed after exit)
  --read-only     Mount workdir as read-only (requires new container)
  --shell         Start a shell (default shell) instead of default CMD
  --cmd ...       Run a custom command (must be last; cannot combine with --shell)
  --cpu NUM       CPU cores for container
  --mem SIZE      Memory limit (e.g. 8G)
EOF
}

usage_auth() {
  cat <<'EOF'
Usage: codexctl auth [options]

Options:
  --name NAME   Auth container name (default: codex-openai-auth-<dir>)
  --image NAME  Image to use (default: codex)
EOF
}

usage_exec() {
  cat <<'EOF'
Usage: codexctl exec [options] [command...]

Options:
  --name NAME  Container name (default: codex-<dir>)

If no command is provided, exec runs the default shell.
EOF
}

usage_su_exec() {
  cat <<'EOF'
Usage: codexctl su-exec [options] [command...]

Options:
  --name NAME  Container name (default: codex-<dir>)

If no command is provided, su-exec runs the default shell as root.
EOF
}

usage_simple_name() {
  cat <<'EOF'
Usage: codexctl <start|stop|restart|rm> [--name NAME]
EOF
}

build_cmd() {
  local image=""
  local rebuild=0
  local refresh_base=0
  local pull_base=0
  local no_cache=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --image) image="$2"; shift 2 ;;
      --rebuild) rebuild=1; shift ;;
      --refresh-base) refresh_base=1; shift ;;
      --pull-base) pull_base=1; shift ;;
      --help) usage_build; return 0 ;;
      *) echo "Error: Unknown option for build: $1" >&2; usage_build; return 1 ;;
    esac
  done

  require_container
  if [ "$rebuild" -eq 1 ]; then
    no_cache="--no-cache"
  fi
  remove_image() {
    local name="$1"
    if "$CONTAINER_CMD" image rm "$name" >/dev/null 2>&1; then
      echo "Removed base image: $name"
      return 0
    fi
    if "$CONTAINER_CMD" image delete "$name" >/dev/null 2>&1; then
      echo "Removed base image: $name"
      return 0
    fi
    echo "Base image not removed (may not exist or command unsupported): $name" >&2
  }
  base_image_from_file() {
    awk 'toupper($1) == "FROM" { print $2; exit }' "$1"
  }
  is_local_base_image() {
    case "$1" in
      codex|codex-python) return 0 ;;
      *) return 1 ;;
    esac
  }
  refresh_base_image() {
    local file="$1"
    local base
    base="$(base_image_from_file "$file")"
    if [ -n "$base" ]; then
      if is_local_base_image "$base"; then
        echo "Skipping base image removal for local image: $base"
        return 0
      fi
      remove_image "$base"
    fi
  }
  pull_base_image() {
    local file="$1"
    local base
    base="$(base_image_from_file "$file")"
    if [ -n "$base" ]; then
      if is_local_base_image "$base"; then
        echo "Skipping base image pull for local image: $base"
        return 0
      fi
      "$CONTAINER_CMD" image pull "$base"
    fi
  }
  build_one() {
    local name="$1"
    local file="$2"
    local file_path="$SCRIPT_DIR/$file"
    local context="$SCRIPT_DIR"
    if [ "$rebuild" -eq 0 ] && image_exists "$name"; then
      echo "Image already exists: $name (use --rebuild to rebuild)"
      return 0
    fi
    if [ "$refresh_base" -eq 1 ]; then
      refresh_base_image "$file_path"
    fi
    if [ "$pull_base" -eq 1 ]; then
      pull_base_image "$file_path"
    fi
    if [ -n "$no_cache" ]; then
      "$CONTAINER_CMD" build -t "$name" -f "$file_path" "$no_cache" "$context"
    else
      "$CONTAINER_CMD" build -t "$name" -f "$file_path" "$context"
    fi
  }
  case "$image" in
    "") build_one codex DockerFile
        build_one codex-python DockerFile.python
        build_one codex-office DockerFile.office
        build_one codex-swift DockerFile.swift
        ;;
    codex) build_one codex DockerFile ;;
    codex-python) build_one codex DockerFile
        build_one codex-python DockerFile.python ;;
    codex-swift) build_one codex-swift DockerFile.swift ;;
    codex-office) build_one codex DockerFile
        build_one codex-python DockerFile.python
        build_one codex-office DockerFile.office ;;
    *) die "Unknown image: $image" ;;
  esac
}

run_auth_flow() {
  local image="$1"
  local auth_name="$2"
  local created=0

  cleanup_auth_container() {
    if [ "$created" -eq 1 ] && container_exists "$auth_name"; then
      "$CONTAINER_CMD" stop "$auth_name" >/dev/null 2>&1 || true
      "$CONTAINER_CMD" rm "$auth_name" >/dev/null 2>&1 || true
    fi
  }

  trap cleanup_auth_container EXIT

  [ -x "$KEYCHAIN_SCRIPT" ] || die "Missing $KEYCHAIN_SCRIPT"

  if container_exists "$auth_name"; then
    die "Auth container already exists: $auth_name (remove it and retry)"
  fi

  "$CONTAINER_CMD" create -t \
    --name "$auth_name" \
    "$image" sh -c 'sleep infinity'
  created=1

  "$CONTAINER_CMD" start "$auth_name"
  "$CONTAINER_CMD" exec -it "$auth_name" bash -lc 'codex login --device-auth'
  "$KEYCHAIN_SCRIPT" store-from-container "$auth_name"
  "$CONTAINER_CMD" stop "$auth_name"
  "$CONTAINER_CMD" rm "$auth_name"
  created=0
  trap - EXIT
}

ensure_keychain() {
  [ -x "$KEYCHAIN_SCRIPT" ] || die "Missing $KEYCHAIN_SCRIPT"
  "$KEYCHAIN_SCRIPT" verify >/dev/null 2>&1
}

auth_info_from_json() {
  local script
  script="$(cat <<'PY'
import json
import re
import sys

raw = sys.stdin.buffer.read()

def extract_from_json(payload):
    token = payload.get("refresh_token", "")
    if not token:
        tokens = payload.get("tokens", {})
        if isinstance(tokens, dict):
            token = tokens.get("refresh_token", "")
    last_refresh = payload.get("last_refresh", "")
    return token, last_refresh

try:
    data = json.loads(raw.decode("utf-8"))
    token, last_refresh = extract_from_json(data)
    print(f"{token}\t{last_refresh}")
except Exception:
    text = raw.decode("utf-8", "ignore")
    token_match = re.search(r'"refresh_token"\s*:\s*"([^"]+)"', text)
    refresh_match = re.search(r'"last_refresh"\s*:\s*"([^"]+)"', text)
    token = token_match.group(1) if token_match else ""
    last_refresh = refresh_match.group(1) if refresh_match else ""
    print(f"{token}\t{last_refresh}")
PY
)"
  python_exec "$script"
}

keychain_auth_info() {
  "$KEYCHAIN_SCRIPT" read | auth_info_from_json
}

container_auth_info() {
  local name="$1"
  if ! "$CONTAINER_CMD" exec "$name" "${SETPRIV_ARGS[@]}" test -f /home/coder/.codex/auth.json; then
    echo -e "\t"
    return 0
  fi
  "$CONTAINER_CMD" exec "$name" "${SETPRIV_ARGS[@]}" cat /home/coder/.codex/auth.json | auth_info_from_json
}

sync_openai_auth_to_container() {
  local name="$1"
  if ! ensure_keychain; then
    die "Missing OpenAI auth in Keychain. Run: codexctl auth"
  fi
  local keychain_info
  local keychain_token
  local keychain_refresh
  keychain_info="$(keychain_auth_info)"
  IFS=$'\t' read -r keychain_token keychain_refresh <<<"$keychain_info"
  if [ -z "$keychain_token" ]; then
    die "Keychain auth missing refresh_token. Run: codexctl auth"
  fi
  local container_info
  local container_token
  local container_refresh
  container_info="$(container_auth_info "$name")"
  IFS=$'\t' read -r container_token container_refresh <<<"$container_info"
  if [ -z "$container_token" ]; then
    echo "Refreshing OpenAI auth in $name" >&2
    "$KEYCHAIN_SCRIPT" load-to-container "$name"
    return 0
  fi
  if [ "$container_token" = "$keychain_token" ] && [ "$container_refresh" = "$keychain_refresh" ]; then
    return 0
  fi
  echo "Refreshing OpenAI auth in $name" >&2
  "$KEYCHAIN_SCRIPT" load-to-container "$name"
}

sync_openai_auth_from_container() {
  local name="$1"
  local container_info
  local container_token
  local container_refresh
  container_info="$(container_auth_info "$name")"
  IFS=$'\t' read -r container_token container_refresh <<<"$container_info"
  if [ -z "$container_token" ] || [ -z "$container_refresh" ]; then
    return 0
  fi
  if ! ensure_keychain; then
    echo "Keychain auth missing; skipping post-run sync from $name" >&2
    return 0
  fi
  local keychain_info
  local keychain_token
  local keychain_refresh
  keychain_info="$(keychain_auth_info)"
  IFS=$'\t' read -r keychain_token keychain_refresh <<<"$keychain_info"
  if [ -z "$keychain_token" ]; then
    echo "Keychain auth missing refresh_token; skipping post-run sync from $name" >&2
    return 0
  fi
  if [ -z "$keychain_refresh" ] || [[ "$container_refresh" < "$keychain_refresh" ]] || [ "$container_refresh" = "$keychain_refresh" ]; then
    return 0
  fi
  echo "Updating Keychain auth from $name" >&2
  "$KEYCHAIN_SCRIPT" store-from-container "$name"
}

run_container() {
  local name="$1"
  local image="$2"
  local temp="$3"
  local shell="$4"
  local cpu="$5"
  local mem="$6"
  local read_only="$7"
  local pre_exec="$8"
  local post_exec="$9"
  shift 9
  local cmd=("$@")
  local exit_code=0
  local started=0
  local already_running=0
  local actual_name="$name"

  # Execute command inside the container and preserve the exit code.
  run_exec() {
    if [ "$shell" -eq 1 ]; then
      if ! "$CONTAINER_CMD" exec -it "$actual_name" "${SETPRIV_ARGS[@]}" "$DEFAULT_SHELL" "-l"; then
        exit_code=$?
      fi
    else
      if ! "$CONTAINER_CMD" exec -it "$actual_name" "${SETPRIV_ARGS[@]}" "${cmd[@]}"; then
        exit_code=$?
      fi
    fi
  }

  # Lifecycle: create if missing, start if needed, pre_exec, exec, stop, remove if temp.
  if [ -n "$actual_name" ] && container_exists "$actual_name"; then
    validate_mount_mode "$actual_name" "$read_only"
  fi
  if [ -n "$actual_name" ] && container_running "$actual_name"; then
    already_running=1
  else
    if [ -n "$actual_name" ] && [ "$temp" -eq 1 ] && container_exists "$actual_name"; then
      die "Container already exists: $actual_name (omit --temp or remove it)"
    fi
    if [ "$temp" -eq 0 ] && [ -z "$actual_name" ]; then
      die "Missing container name"
    fi

    if [ -z "$actual_name" ] || ! container_exists "$actual_name"; then
      echo "Creating container..." >&2
      local create_cmd=("$CONTAINER_CMD" create -t)
      if [ -n "$cpu" ]; then
        create_cmd+=(-c "$cpu")
      fi
      if [ -n "$mem" ]; then
        create_cmd+=(-m "$mem")
      fi
      if [ -n "$actual_name" ]; then
        create_cmd+=(--name "$actual_name")
      fi
      local mount_opts="type=bind,src=$PWD,dst=/workdir"
      if [ "$read_only" -eq 1 ]; then
        mount_opts="${mount_opts},readonly"
      fi
      create_cmd+=(
        --mount "$mount_opts"
        "$image" sh -c 'sleep infinity'
      )
      if [ -z "$actual_name" ]; then
        actual_name="$("${create_cmd[@]}")"
        [ -n "$actual_name" ] || die "Failed to create temporary container"
      else
        "${create_cmd[@]}"
      fi
    fi

    echo "Starting container: $actual_name" >&2
    "$CONTAINER_CMD" start "$actual_name"
    started=1
  fi

  if [ -n "$pre_exec" ]; then
    "$pre_exec" "$actual_name"
  fi
  run_exec
  if [ -n "$post_exec" ]; then
    if ! "$post_exec" "$actual_name"; then
      warn "post-run step failed for $actual_name"
    fi
  fi
  if [ "$already_running" -eq 1 ]; then
    return "$exit_code"
  fi
  if [ "$started" -eq 1 ]; then
    echo "Stopping container: $actual_name" >&2
    "$CONTAINER_CMD" stop "$actual_name" >/dev/null 2>&1
  fi
  if [ "$temp" -eq 1 ]; then
    echo "Removing container: $actual_name" >&2
    "$CONTAINER_CMD" rm "$actual_name" >/dev/null 2>&1
  fi
  return "$exit_code"
}

run_mode() {
  local name="$1"
  local image="$2"
  local temp="$3"
  local shell="$4"
  local openai="$5"
  local auth="$6"
  local cpu="$7"
  local mem="$8"
  local read_only="$9"
  shift 9
  local -a cmd_override=("$@")
  local pre_exec=""
  local post_exec=""
  local cmd=("${DEFAULT_CODEX_CMD[@]}" --profile "$DEFAULT_CODEX_PROFILE")

  if [ "$openai" -eq 1 ]; then
    pre_exec="openai_pre_exec"
    post_exec="openai_post_exec"
    cmd=("${DEFAULT_CODEX_CMD[@]}")
    if [ "$auth" -eq 1 ] || ! ensure_keychain; then
      run_auth_flow "$image" "$(default_name "$AUTH_NAME_PREFIX")"
    fi
  fi

  if [ "${#cmd_override[@]}" -gt 0 ]; then
    cmd=("${cmd_override[@]}")
    shell=0
  fi

  run_container "$name" "$image" "$temp" "$shell" "$cpu" "$mem" "$read_only" "$pre_exec" "$post_exec" "${cmd[@]}"
}

openai_pre_exec() {
  local name="$1"
  sync_openai_auth_to_container "$name"
}

openai_post_exec() {
  local name="$1"
  sync_openai_auth_from_container "$name"
}

run_cmd() {
  local name=""
  local image=""
  local openai=0
  local auth=0
  local temp=0
  local shell=0
  local read_only=0
  local cpu=""
  local mem=""
  local -a cmd_override=()
  local cmd_override_set=0
  local shell_set=0

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --image) image="$2"; shift 2 ;;
      --openai) openai=1; shift ;;
      --auth) auth=1; shift ;;
      --temp) temp=1; shift ;;
      --read-only) read_only=1; shift ;;
      --shell) shell=1; shell_set=1; shift ;;
      --cmd) shift; cmd_override_set=1; cmd_override=("$@"); break ;;
      --cpu) cpu="$2"; shift 2 ;;
      --mem) mem="$2"; shift 2 ;;
      --help) usage_run; return 0 ;;
      *) die "Unknown option for run: $1" ;;
    esac
  done

  require_container
  if [ "$shell_set" -eq 1 ] && [ "$cmd_override_set" -eq 1 ]; then
    die "Cannot combine --shell with --cmd"
  fi
  if [ "$cmd_override_set" -eq 1 ] && [ "${#cmd_override[@]}" -eq 0 ]; then
    die "Missing command after --cmd"
  fi
  if [ "$cmd_override_set" -eq 1 ] && [ "${#cmd_override[@]}" -eq 1 ]; then
    case "${cmd_override[0]}" in
      *[[:space:]]*) cmd_override=("$DEFAULT_SHELL" "-lc" "${cmd_override[0]}") ;;
    esac
  fi
  if [ "$auth" -eq 1 ] && [ "$openai" -eq 0 ]; then
    die "--auth requires --openai"
  fi

  [ -n "$image" ] || image="$DEFAULT_IMAGE"
  if [ -z "$name" ] && [ "$temp" -eq 0 ]; then
    name="$(default_name "$DEFAULT_NAME_PREFIX")"
  fi

  run_mode "$name" "$image" "$temp" "$shell" "$openai" "$auth" "$cpu" "$mem" "$read_only" ${cmd_override[@]+"${cmd_override[@]}"}
}

auth_cmd() {
  local name=""
  local image="$DEFAULT_IMAGE"

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --image) image="$2"; shift 2 ;;
      --help) usage_auth; return 0 ;;
      *) die "Unknown option for auth: $1" ;;
    esac
  done

  require_container
  if [ -z "$name" ]; then
    name="$(default_name "$AUTH_NAME_PREFIX")"
  fi
  run_auth_flow "$image" "$name"
  echo "Auth updated. Restart any running --openai containers to pick up the new token." >&2
}

exec_cmd() {
  local name=""
  local cmd=()

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --help) usage_exec; return 0 ;;
      --) shift; cmd=("$@"); break ;;
      --*) die "Unknown option for exec: $1" ;;
      *) cmd=("$@"); break ;;
    esac
  done

  require_container

  if [ -z "$name" ]; then
    name="$(default_name "$DEFAULT_NAME_PREFIX")"
  fi

  if [ "${#cmd[@]}" -eq 0 ]; then
    cmd=("$DEFAULT_SHELL" "-l")
  fi
  if [ "${#cmd[@]}" -eq 1 ]; then
    case "${cmd[0]}" in
      *[[:space:]]*) cmd=("$DEFAULT_SHELL" "-lc" "${cmd[0]}") ;;
    esac
  fi

  if ! container_running "$name"; then
    die "Container not running: $name"
  fi

  "$CONTAINER_CMD" exec -it "$name" "${SETPRIV_ARGS[@]}" "${cmd[@]}"
}

su_exec_cmd() {
  local name=""
  local cmd=()

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --help) usage_su_exec; return 0 ;;
      --) shift; cmd=("$@"); break ;;
      --*) die "Unknown option for su-exec: $1" ;;
      *) cmd=("$@"); break ;;
    esac
  done

  require_container

  if [ -z "$name" ]; then
    name="$(default_name "$DEFAULT_NAME_PREFIX")"
  fi

  if [ "${#cmd[@]}" -eq 0 ]; then
    cmd=("$DEFAULT_SHELL" "-l")
  fi
  if [ "${#cmd[@]}" -eq 1 ]; then
    case "${cmd[0]}" in
      *[[:space:]]*) cmd=("$DEFAULT_SHELL" "-lc" "${cmd[0]}") ;;
    esac
  fi

  if ! container_running "$name"; then
    die "Container not running: $name"
  fi

  "$CONTAINER_CMD" exec -u 0 -it "$name" "${cmd[@]}"
}

simple_name_cmd() {
  local action="$1"
  shift
  local name=""
  local openai=0

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --openai) openai=1; shift ;;
      --help) usage_simple_name; return 0 ;;
      *) die "Unknown option: $1" ;;
    esac
  done

  require_container

  if [ -z "$name" ]; then
    name="$(default_name "$DEFAULT_NAME_PREFIX")"
  fi

  case "$action" in
    start) "$CONTAINER_CMD" start "$name" ;;
    stop) "$CONTAINER_CMD" stop "$name" ;;
    restart) "$CONTAINER_CMD" restart "$name" ;;
    rm) "$CONTAINER_CMD" rm "$name" ;;
    *) die "Unknown action: $action" ;;
  esac
}

ls_cmd() {
  require_container
  "$CONTAINER_CMD" ls -a
}

cmd="${1:-}"
case "$cmd" in
  build) shift; build_cmd "$@" ;;
  run) shift; run_cmd "$@" ;;
  auth) shift; auth_cmd "$@" ;;
  exec) shift; exec_cmd "$@" ;;
  su-exec) shift; su_exec_cmd "$@" ;;
  start|stop|restart|rm) shift; simple_name_cmd "$cmd" "$@" ;;
  ls) shift; ls_cmd "$@" ;;
  --help|-h|help|"") usage ;;
  *) die "Unknown command: $cmd" ;;
esac
