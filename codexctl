#!/usr/bin/env bash
set -euo pipefail

CONTAINER_CMD="${CONTAINER_CMD:-container}"
DEFAULT_IMAGE="codex"
DEFAULT_NAME_PREFIX="codex-"
AUTH_NAME_PREFIX="codex-openai-auth-"
DEFAULT_SHELL="${CODEX_SHELL:-bash}"
DEFAULT_CODEX_PROFILE="gpt-oss"
DEFAULT_CODEX_CMD=(codex)
SETPRIV_ARGS=(setpriv --inh-caps=-all --ambient-caps=-all --bounding-set=-all --no-new-privs --)

resolve_script_path() {
  local path="$1"
  while [ -L "$path" ]; do
    local target
    target="$(readlink "$path")"
    if [[ "$target" != /* ]]; then
      path="$(CDPATH= cd -- "$(dirname -- "$path")" && pwd)/$target"
    else
      path="$target"
    fi
  done
  echo "$path"
}

SCRIPT_PATH="$(resolve_script_path "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(CDPATH= cd -- "$(dirname -- "$SCRIPT_PATH")" && pwd)"
KEYCHAIN_SCRIPT="$SCRIPT_DIR/codex-auth-keychain.sh"

die() {
  echo "Error: $*" >&2
  exit 1
}

require_container() {
  command -v "$CONTAINER_CMD" >/dev/null 2>&1 || die "Missing '$CONTAINER_CMD' command"
}

container_list_all() {
  "$CONTAINER_CMD" ls -a 2>/dev/null || true
}

container_list_running() {
  "$CONTAINER_CMD" ls 2>/dev/null || true
}

container_exists() {
  container_list_all | grep -q -E "(^|[[:space:]])$1([[:space:]]|$)"
}

container_running() {
  container_list_running | grep -q -E "(^|[[:space:]])$1([[:space:]]|$)"
}

image_list() {
  "$CONTAINER_CMD" image ls 2>/dev/null || "$CONTAINER_CMD" images 2>/dev/null || true
}

image_exists() {
  image_list | grep -q -E "(^|[[:space:]])$1([[:space:]]|$)"
}

default_name() {
  local prefix="$1"
  echo "${prefix}$(basename "$PWD")"
}

usage() {
  cat <<'EOF'
Usage: codexctl <command> [options]

Commands:
  build      Build Codex images
  run        Create/start a container for the current directory
  auth       Run OpenAI device auth flow and store in Keychain
  exec       Exec into a running container (default: bash)
  su-exec    Exec into a running container as root (default: bash)
  start      Start a container
  stop       Stop a running container
  restart    Restart a container
  rm         Remove a container
  ls         List containers

Run "codexctl <command> --help" for command-specific options.
EOF
}

usage_build() {
  cat <<'EOF'
Usage: codexctl build [--image NAME] [--rebuild] [--pull-base] [--refresh-base]

Options:
  --image NAME  One of: codex, codex-python, codex-swift, codex-office (default: all)
  --rebuild     Rebuild images even if they already exist (disables build cache)
  --pull-base     Pull the base image before building
  --refresh-base  Remove the base image first so it is re-fetched
EOF
}

usage_run() {
  cat <<'EOF'
Usage: codexctl run [options]

Options:
  --name NAME     Container name (default: codex-<dir>)
  --image NAME    Image to use (default: codex)
  --openai        Use OpenAI mode (device auth)
  --auth          Force OpenAI login flow
  --temp          Create a throwaway container (auto-removed after exit)
  --shell         Start a shell (default shell) instead of default CMD
  --cmd ...       Run a custom command (must be last; cannot combine with --shell)
  --cpu NUM       CPU cores for container
  --mem SIZE      Memory limit (e.g. 8G)
EOF
}

usage_auth() {
  cat <<'EOF'
Usage: codexctl auth [options]

Options:
  --name NAME   Auth container name (default: codex-openai-auth-<dir>)
  --image NAME  Image to use (default: codex)
EOF
}

usage_exec() {
  cat <<'EOF'
Usage: codexctl exec [options] [command...]

Options:
  --name NAME  Container name (default: codex-<dir>)

If no command is provided, exec runs the default shell.
EOF
}

usage_su_exec() {
  cat <<'EOF'
Usage: codexctl su-exec [options] [command...]

Options:
  --name NAME  Container name (default: codex-<dir>)

If no command is provided, su-exec runs the default shell as root.
EOF
}

usage_simple_name() {
  cat <<'EOF'
Usage: codexctl <start|stop|restart|rm> [--name NAME]
EOF
}

build_cmd() {
  local image=""
  local rebuild=0
  local refresh_base=0
  local pull_base=0
  local no_cache=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --image) image="$2"; shift 2 ;;
      --rebuild) rebuild=1; shift ;;
      --refresh-base) refresh_base=1; shift ;;
      --pull-base) pull_base=1; shift ;;
      --help) usage_build; return 0 ;;
      *) echo "Error: Unknown option for build: $1" >&2; usage_build; return 1 ;;
    esac
  done

  require_container
  if [ "$rebuild" -eq 1 ]; then
    no_cache="--no-cache"
  fi
  remove_image() {
    local name="$1"
    if "$CONTAINER_CMD" image rm "$name" >/dev/null 2>&1; then
      echo "Removed base image: $name"
      return 0
    fi
    if "$CONTAINER_CMD" image delete "$name" >/dev/null 2>&1; then
      echo "Removed base image: $name"
      return 0
    fi
    echo "Base image not removed (may not exist or command unsupported): $name" >&2
  }
  base_image_from_file() {
    awk 'toupper($1) == "FROM" { print $2; exit }' "$1"
  }
  refresh_base_image() {
    local file="$1"
    local base
    base="$(base_image_from_file "$file")"
    if [ -n "$base" ]; then
      remove_image "$base"
    fi
  }
  pull_base_image() {
    local file="$1"
    local base
    base="$(base_image_from_file "$file")"
    if [ -n "$base" ]; then
      "$CONTAINER_CMD" image pull "$base"
    fi
  }
  build_one() {
    local name="$1"
    local file="$2"
    local file_path="$SCRIPT_DIR/$file"
    local context="$SCRIPT_DIR"
    if [ "$rebuild" -eq 0 ] && image_exists "$name"; then
      echo "Image already exists: $name (use --rebuild to rebuild)"
      return 0
    fi
    if [ "$refresh_base" -eq 1 ]; then
      refresh_base_image "$file_path"
    fi
    if [ "$pull_base" -eq 1 ]; then
      pull_base_image "$file_path"
    fi
    if [ -n "$no_cache" ]; then
      "$CONTAINER_CMD" build -t "$name" -f "$file_path" "$no_cache" "$context"
    else
      "$CONTAINER_CMD" build -t "$name" -f "$file_path" "$context"
    fi
  }
  case "$image" in
    "") build_one codex DockerFile
        build_one codex-python DockerFile.python
        build_one codex-swift DockerFile.swift
        build_one codex-office DockerFile.office
        ;;
    codex) build_one codex DockerFile ;;
    codex-python) build_one codex-python DockerFile.python ;;
    codex-swift) build_one codex-swift DockerFile.swift ;;
    codex-office) build_one codex-office DockerFile.office ;;
    *) die "Unknown image: $image" ;;
  esac
}

run_auth_flow() {
  local image="$1"
  local auth_name="$2"

  [ -x "$KEYCHAIN_SCRIPT" ] || die "Missing $KEYCHAIN_SCRIPT"

  if container_exists "$auth_name"; then
    die "Auth container already exists: $auth_name (remove it and retry)"
  fi

  "$CONTAINER_CMD" create -t \
    --name "$auth_name" \
    --mount "type=bind,src=$PWD,dst=/workdir" \
    "$image" sh -c 'sleep infinity'

  "$CONTAINER_CMD" start "$auth_name"
  "$CONTAINER_CMD" exec -it "$auth_name" bash -lc 'codex login --device-auth'
  "$KEYCHAIN_SCRIPT" store-from-container "$auth_name"
  "$CONTAINER_CMD" stop "$auth_name"
  "$CONTAINER_CMD" rm "$auth_name"
}

ensure_keychain() {
  [ -x "$KEYCHAIN_SCRIPT" ] || die "Missing $KEYCHAIN_SCRIPT"
  "$KEYCHAIN_SCRIPT" verify >/dev/null 2>&1
}

run_container() {
  local name="$1"
  local image="$2"
  local temp="$3"
  local shell="$4"
  local cpu="$5"
  local mem="$6"
  local pre_exec="$7"
  shift 7
  local cmd=("$@")
  local exit_code=0
  local started=0
  local already_running=0
  local actual_name="$name"

  # Execute command inside the container and preserve the exit code.
  run_exec() {
    if [ "$shell" -eq 1 ]; then
      if ! "$CONTAINER_CMD" exec -it "$actual_name" "${SETPRIV_ARGS[@]}" "$DEFAULT_SHELL" "-l"; then
        exit_code=$?
      fi
    else
      if ! "$CONTAINER_CMD" exec -it "$actual_name" "${SETPRIV_ARGS[@]}" "${cmd[@]}"; then
        exit_code=$?
      fi
    fi
  }

  # Lifecycle: create if missing, start if needed, pre_exec, exec, stop, remove if temp.
  if [ -n "$actual_name" ] && container_running "$actual_name"; then
    already_running=1
  else
    if [ -n "$actual_name" ] && [ "$temp" -eq 1 ] && container_exists "$actual_name"; then
      die "Container already exists: $actual_name (omit --temp or remove it)"
    fi
    if [ "$temp" -eq 0 ] && [ -z "$actual_name" ]; then
      die "Missing container name"
    fi

    if [ -z "$actual_name" ] || ! container_exists "$actual_name"; then
      echo "Creating container..." >&2
      local create_cmd=("$CONTAINER_CMD" create -t)
      if [ -n "$cpu" ]; then
        create_cmd+=(-c "$cpu")
      fi
      if [ -n "$mem" ]; then
        create_cmd+=(-m "$mem")
      fi
      if [ -n "$actual_name" ]; then
        create_cmd+=(--name "$actual_name")
      fi
      create_cmd+=(
        --mount "type=bind,src=$PWD,dst=/workdir"
        "$image" sh -c 'sleep infinity'
      )
      if [ -z "$actual_name" ]; then
        actual_name="$("${create_cmd[@]}")"
        [ -n "$actual_name" ] || die "Failed to create temporary container"
      else
        "${create_cmd[@]}"
      fi
    fi

    echo "Starting container: $actual_name" >&2
    "$CONTAINER_CMD" start "$actual_name"
    started=1
  fi

  if [ -n "$pre_exec" ]; then
    "$pre_exec" "$actual_name"
  fi
  run_exec
  if [ "$already_running" -eq 1 ]; then
    return "$exit_code"
  fi
  if [ "$started" -eq 1 ]; then
    echo "Stopping container: $actual_name" >&2
    "$CONTAINER_CMD" stop "$actual_name" >/dev/null 2>&1
  fi
  if [ "$temp" -eq 1 ]; then
    echo "Removing container: $actual_name" >&2
    "$CONTAINER_CMD" rm "$actual_name" >/dev/null 2>&1
  fi
  return "$exit_code"
}

run_mode() {
  local name="$1"
  local image="$2"
  local temp="$3"
  local shell="$4"
  local openai="$5"
  local auth="$6"
  local cpu="$7"
  local mem="$8"
  shift 8
  local -a cmd_override=("$@")
  local pre_exec=""
  local cmd=("${DEFAULT_CODEX_CMD[@]}" --profile "$DEFAULT_CODEX_PROFILE")

  if [ "$openai" -eq 1 ]; then
    pre_exec="openai_pre_exec"
    cmd=("${DEFAULT_CODEX_CMD[@]}")
    if [ "$auth" -eq 1 ] || ! ensure_keychain; then
      run_auth_flow "$image" "$(default_name "$AUTH_NAME_PREFIX")"
    fi
  fi

  if [ "${#cmd_override[@]}" -gt 0 ]; then
    cmd=("${cmd_override[@]}")
    shell=0
  fi

  run_container "$name" "$image" "$temp" "$shell" "$cpu" "$mem" "$pre_exec" "${cmd[@]}"
}

openai_pre_exec() {
  local name="$1"
  if ! "$CONTAINER_CMD" exec "$name" "${SETPRIV_ARGS[@]}" test -f /home/coder/.codex/auth.json; then
    "$KEYCHAIN_SCRIPT" load-to-container "$name"
  fi
}

run_cmd() {
  local name=""
  local image=""
  local openai=0
  local auth=0
  local temp=0
  local shell=0
  local cpu=""
  local mem=""
  local -a cmd_override=()
  local cmd_override_set=0
  local shell_set=0

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --image) image="$2"; shift 2 ;;
      --openai) openai=1; shift ;;
      --auth) auth=1; shift ;;
      --temp) temp=1; shift ;;
      --shell) shell=1; shell_set=1; shift ;;
      --cmd) shift; cmd_override_set=1; cmd_override=("$@"); break ;;
      --cpu) cpu="$2"; shift 2 ;;
      --mem) mem="$2"; shift 2 ;;
      --help) usage_run; return 0 ;;
      *) die "Unknown option for run: $1" ;;
    esac
  done

  require_container
  if [ "$shell_set" -eq 1 ] && [ "$cmd_override_set" -eq 1 ]; then
    die "Cannot combine --shell with --cmd"
  fi
  if [ "$cmd_override_set" -eq 1 ] && [ "${#cmd_override[@]}" -eq 0 ]; then
    die "Missing command after --cmd"
  fi
  if [ "$cmd_override_set" -eq 1 ] && [ "${#cmd_override[@]}" -eq 1 ]; then
    case "${cmd_override[0]}" in
      *[[:space:]]*) cmd_override=("$DEFAULT_SHELL" "-lc" "${cmd_override[0]}") ;;
    esac
  fi
  if [ "$auth" -eq 1 ] && [ "$openai" -eq 0 ]; then
    die "--auth requires --openai"
  fi

  [ -n "$image" ] || image="$DEFAULT_IMAGE"
  if [ -z "$name" ] && [ "$temp" -eq 0 ]; then
    name="$(default_name "$DEFAULT_NAME_PREFIX")"
  fi

  run_mode "$name" "$image" "$temp" "$shell" "$openai" "$auth" "$cpu" "$mem" ${cmd_override[@]+"${cmd_override[@]}"}
}

auth_cmd() {
  local name=""
  local image="$DEFAULT_IMAGE"

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --image) image="$2"; shift 2 ;;
      --help) usage_auth; return 0 ;;
      *) die "Unknown option for auth: $1" ;;
    esac
  done

  require_container
  if [ -z "$name" ]; then
    name="$(default_name "$AUTH_NAME_PREFIX")"
  fi
  run_auth_flow "$image" "$name"
}

exec_cmd() {
  local name=""
  local cmd=()

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --help) usage_exec; return 0 ;;
      --) shift; cmd=("$@"); break ;;
      --*) die "Unknown option for exec: $1" ;;
      *) cmd=("$@"); break ;;
    esac
  done

  require_container

  if [ -z "$name" ]; then
    name="$(default_name "$DEFAULT_NAME_PREFIX")"
  fi

  if [ "${#cmd[@]}" -eq 0 ]; then
    cmd=("$DEFAULT_SHELL" "-l")
  fi
  if [ "${#cmd[@]}" -eq 1 ]; then
    case "${cmd[0]}" in
      *[[:space:]]*) cmd=("$DEFAULT_SHELL" "-lc" "${cmd[0]}") ;;
    esac
  fi

  if ! container_running "$name"; then
    die "Container not running: $name"
  fi

  "$CONTAINER_CMD" exec -it "$name" "${SETPRIV_ARGS[@]}" "${cmd[@]}"
}

su_exec_cmd() {
  local name=""
  local cmd=()

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --help) usage_su_exec; return 0 ;;
      --) shift; cmd=("$@"); break ;;
      --*) die "Unknown option for su-exec: $1" ;;
      *) cmd=("$@"); break ;;
    esac
  done

  require_container

  if [ -z "$name" ]; then
    name="$(default_name "$DEFAULT_NAME_PREFIX")"
  fi

  if [ "${#cmd[@]}" -eq 0 ]; then
    cmd=("$DEFAULT_SHELL" "-l")
  fi
  if [ "${#cmd[@]}" -eq 1 ]; then
    case "${cmd[0]}" in
      *[[:space:]]*) cmd=("$DEFAULT_SHELL" "-lc" "${cmd[0]}") ;;
    esac
  fi

  if ! container_running "$name"; then
    die "Container not running: $name"
  fi

  "$CONTAINER_CMD" exec -u 0 -it "$name" "${cmd[@]}"
}

simple_name_cmd() {
  local action="$1"
  shift
  local name=""
  local openai=0

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --openai) openai=1; shift ;;
      --help) usage_simple_name; return 0 ;;
      *) die "Unknown option: $1" ;;
    esac
  done

  require_container

  if [ -z "$name" ]; then
    name="$(default_name "$DEFAULT_NAME_PREFIX")"
  fi

  case "$action" in
    start) "$CONTAINER_CMD" start "$name" ;;
    stop) "$CONTAINER_CMD" stop "$name" ;;
    restart) "$CONTAINER_CMD" restart "$name" ;;
    rm) "$CONTAINER_CMD" rm "$name" ;;
    *) die "Unknown action: $action" ;;
  esac
}

ls_cmd() {
  require_container
  "$CONTAINER_CMD" ls -a
}

cmd="${1:-}"
case "$cmd" in
  build) shift; build_cmd "$@" ;;
  run) shift; run_cmd "$@" ;;
  auth) shift; auth_cmd "$@" ;;
  exec) shift; exec_cmd "$@" ;;
  su-exec) shift; su_exec_cmd "$@" ;;
  start|stop|restart|rm) shift; simple_name_cmd "$cmd" "$@" ;;
  ls) shift; ls_cmd "$@" ;;
  --help|-h|help|"") usage ;;
  *) die "Unknown command: $cmd" ;;
esac
