#!/usr/bin/env bash
set -euo pipefail

CONTAINER_CMD="${CONTAINER_CMD:-container}"
DEFAULT_IMAGE="codex"
DEFAULT_NAME_PREFIX="codex-"
OPENAI_NAME_PREFIX="codex-openai-"
AUTH_NAME_PREFIX="codex-openai-auth-"
DEFAULT_CODEX_CMD=(codex --dangerously-bypass-approvals-and-sandbox --profile gpt-oss)

resolve_script_path() {
  local path="$1"
  while [ -L "$path" ]; do
    local target
    target="$(readlink "$path")"
    if [[ "$target" != /* ]]; then
      path="$(CDPATH= cd -- "$(dirname -- "$path")" && pwd)/$target"
    else
      path="$target"
    fi
  done
  echo "$path"
}

SCRIPT_PATH="$(resolve_script_path "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(CDPATH= cd -- "$(dirname -- "$SCRIPT_PATH")" && pwd)"
KEYCHAIN_SCRIPT="$SCRIPT_DIR/codex-auth-keychain.sh"

die() {
  echo "Error: $*" >&2
  exit 1
}

require_container() {
  command -v "$CONTAINER_CMD" >/dev/null 2>&1 || die "Missing '$CONTAINER_CMD' command"
}

container_list_all() {
  "$CONTAINER_CMD" ls -a 2>/dev/null || true
}

container_list_running() {
  "$CONTAINER_CMD" ls 2>/dev/null || true
}

container_exists() {
  container_list_all | grep -q -E "(^|[[:space:]])$1([[:space:]]|$)"
}

container_running() {
  container_list_running | grep -q -E "(^|[[:space:]])$1([[:space:]]|$)"
}

image_list() {
  "$CONTAINER_CMD" image ls 2>/dev/null || "$CONTAINER_CMD" images 2>/dev/null || true
}

image_exists() {
  image_list | grep -q -E "(^|[[:space:]])$1([[:space:]]|$)"
}

default_name() {
  local prefix="$1"
  echo "${prefix}$(basename "$PWD")"
}

usage() {
  cat <<'EOF'
Usage: codexctl <command> [options]

Commands:
  build      Build Codex images
  run        Create/start a container for the current directory
  auth       Run OpenAI device auth flow and store in Keychain
  exec       Exec into a running container (default: bash)
  start      Start a container
  stop       Stop a running container
  restart    Restart a container
  rm         Remove a container
  ls         List containers

Run "codexctl <command> --help" for command-specific options.
EOF
}

usage_build() {
  cat <<'EOF'
Usage: codexctl build [--image NAME] [--rebuild] [--pull-base] [--refresh-base]

Options:
  --image NAME  One of: codex, codex-python, codex-swift (default: all)
  --rebuild     Rebuild images even if they already exist (disables build cache)
  --pull-base     Pull the base image before building
  --refresh-base  Remove the base image first so it is re-fetched
EOF
}

usage_run() {
  cat <<'EOF'
Usage: codexctl run [options]

Options:
  --name NAME     Container name (default: codex-<dir> or codex-openai-<dir>)
  --image NAME    Image to use (default: codex)
  --openai        Use OpenAI mode (device auth + codex bypass)
  --auth          Force OpenAI login flow
  --temp          Create a throwaway container (--rm)
  --shell         Start a shell (bash) instead of default CMD
  --cpu NUM       CPU cores for container
  --mem SIZE      Memory limit (e.g. 8G)
EOF
}

usage_auth() {
  cat <<'EOF'
Usage: codexctl auth [options]

Options:
  --name NAME   Auth container name (default: codex-openai-auth-<dir>)
  --image NAME  Image to use (default: codex)
EOF
}

usage_exec() {
  cat <<'EOF'
Usage: codexctl exec [options] [-- command...]

Options:
  --name NAME  Container name (default: codex-<dir> or codex-openai-<dir>)
  --openai     Use OpenAI name prefix
  --shell      Run bash (default)
EOF
}

usage_simple_name() {
  cat <<'EOF'
Usage: codexctl <start|stop|restart|rm> [--name NAME] [--openai]
EOF
}

build_cmd() {
  local image=""
  local rebuild=0
  local refresh_base=0
  local pull_base=0
  local no_cache=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --image) image="$2"; shift 2 ;;
      --rebuild) rebuild=1; shift ;;
      --refresh-base) refresh_base=1; shift ;;
      --pull-base) pull_base=1; shift ;;
      --help) usage_build; return 0 ;;
      *) echo "Error: Unknown option for build: $1" >&2; usage_build; return 1 ;;
    esac
  done

  require_container
  if [ "$rebuild" -eq 1 ]; then
    no_cache="--no-cache"
  fi
  remove_image() {
    local name="$1"
    if "$CONTAINER_CMD" image rm "$name" >/dev/null 2>&1; then
      echo "Removed base image: $name"
      return 0
    fi
    if "$CONTAINER_CMD" image delete "$name" >/dev/null 2>&1; then
      echo "Removed base image: $name"
      return 0
    fi
    echo "Base image not removed (may not exist or command unsupported): $name" >&2
  }
  base_image_from_file() {
    awk 'toupper($1) == "FROM" { print $2; exit }' "$1"
  }
  refresh_base_image() {
    local file="$1"
    local base
    base="$(base_image_from_file "$file")"
    if [ -n "$base" ]; then
      remove_image "$base"
    fi
  }
  pull_base_image() {
    local file="$1"
    local base
    base="$(base_image_from_file "$file")"
    if [ -n "$base" ]; then
      "$CONTAINER_CMD" image pull "$base"
    fi
  }
  build_one() {
    local name="$1"
    local file="$2"
    local file_path="$SCRIPT_DIR/$file"
    local context="$SCRIPT_DIR"
    if [ "$rebuild" -eq 0 ] && image_exists "$name"; then
      echo "Image already exists: $name (use --rebuild to rebuild)"
      return 0
    fi
    if [ "$refresh_base" -eq 1 ]; then
      refresh_base_image "$file_path"
    fi
    if [ "$pull_base" -eq 1 ]; then
      pull_base_image "$file_path"
    fi
    if [ -n "$no_cache" ]; then
      "$CONTAINER_CMD" build -t "$name" -f "$file_path" "$no_cache" "$context"
    else
      "$CONTAINER_CMD" build -t "$name" -f "$file_path" "$context"
    fi
  }
  case "$image" in
    "") build_one codex DockerFile
        build_one codex-python DockerFile.python
        build_one codex-swift DockerFile.swift
        ;;
    codex) build_one codex DockerFile ;;
    codex-python) build_one codex-python DockerFile.python ;;
    codex-swift) build_one codex-swift DockerFile.swift ;;
    *) die "Unknown image: $image" ;;
  esac
}

run_auth_flow() {
  local image="$1"
  local auth_name="$2"

  [ -x "$KEYCHAIN_SCRIPT" ] || die "Missing $KEYCHAIN_SCRIPT"

  if container_exists "$auth_name"; then
    die "Auth container already exists: $auth_name (remove it and retry)"
  fi

  "$CONTAINER_CMD" create -t \
    --name "$auth_name" \
    --mount "type=bind,src=$PWD,dst=/workdir" \
    "$image" sh -c 'sleep infinity'

  "$CONTAINER_CMD" start "$auth_name"
  "$CONTAINER_CMD" exec -it "$auth_name" bash -lc 'codex login --device-auth'
  "$KEYCHAIN_SCRIPT" store-from-container "$auth_name"
  "$CONTAINER_CMD" stop "$auth_name"
  "$CONTAINER_CMD" rm "$auth_name"
}

ensure_keychain() {
  [ -x "$KEYCHAIN_SCRIPT" ] || die "Missing $KEYCHAIN_SCRIPT"
  "$KEYCHAIN_SCRIPT" verify >/dev/null 2>&1
}

run_local() {
  local name="$1"
  local image="$2"
  local temp="$3"
  local shell="$4"
  local cpu="$5"
  local mem="$6"

  if [ -n "$name" ] && container_running "$name"; then
    if [ "$shell" -eq 1 ]; then
      "$CONTAINER_CMD" exec -it "$name" bash
    else
      "$CONTAINER_CMD" exec -it "$name" "${DEFAULT_CODEX_CMD[@]}"
    fi
    return 0
  fi

  if [ -n "$name" ] && [ "$temp" -eq 1 ] && container_exists "$name"; then
    die "Container already exists: $name (omit --temp or remove it)"
  fi

  if [ -n "$name" ] && container_exists "$name"; then
    if [ "$shell" -eq 1 ]; then
      "$CONTAINER_CMD" start "$name"
      "$CONTAINER_CMD" exec -it "$name" bash
    else
      "$CONTAINER_CMD" start -i "$name"
    fi
    return 0
  fi

  local run_args=(-it)
  local mount_arg="type=bind,src=$PWD,dst=/workdir"
  if [ "$temp" -eq 1 ]; then
    run_args+=(--rm)
  elif [ -n "$name" ]; then
    run_args+=(--name "$name")
  fi
  if [ -n "$cpu" ]; then
    run_args+=(-c "$cpu")
  fi
  if [ -n "$mem" ]; then
    run_args+=(-m "$mem")
  fi

  if [ "$shell" -eq 1 ]; then
    "$CONTAINER_CMD" run "${run_args[@]}" --mount "$mount_arg" "$image" bash
  else
    "$CONTAINER_CMD" run "${run_args[@]}" --mount "$mount_arg" "$image"
  fi
}

run_openai() {
  local name="$1"
  local image="$2"
  local temp="$3"
  local shell="$4"
  local auth="$5"
  local cpu="$6"
  local mem="$7"

  [ "$temp" -eq 0 ] || die "OpenAI mode requires a persistent container (omit --temp)"

  if [ -z "$name" ]; then
    name="$(default_name "$OPENAI_NAME_PREFIX")"
  fi

  if [ "$auth" -eq 1 ] || ! ensure_keychain; then
    run_auth_flow "$image" "$(default_name "$AUTH_NAME_PREFIX")"
  fi

  if container_running "$name"; then
    if [ "$shell" -eq 1 ]; then
      if ! "$CONTAINER_CMD" exec "$name" test -f /root/.codex/auth.json; then
        "$KEYCHAIN_SCRIPT" load-to-container "$name"
      fi
      "$CONTAINER_CMD" exec -it "$name" bash
      return 0
    fi
    "$CONTAINER_CMD" exec -it "$name" codex --dangerously-bypass-approvals-and-sandbox
    return 0
  fi

  if ! container_exists "$name"; then
    local create_cmd=("$CONTAINER_CMD" create -t)
    if [ -n "$cpu" ]; then
      create_cmd+=(-c "$cpu")
    fi
    if [ -n "$mem" ]; then
      create_cmd+=(-m "$mem")
    fi
    create_cmd+=(
      --name "$name"
      --mount "type=bind,src=$PWD,dst=/workdir"
      "$image" sh -c 'sleep infinity'
    )
    "${create_cmd[@]}"
  fi

  local started=0
  "$CONTAINER_CMD" start "$name" >/dev/null
  started=1
  if ! "$CONTAINER_CMD" exec "$name" test -f /root/.codex/auth.json; then
    "$KEYCHAIN_SCRIPT" load-to-container "$name"
  fi
  if [ "$shell" -eq 1 ]; then
    "$CONTAINER_CMD" exec -it "$name" bash
  else
    "$CONTAINER_CMD" exec -it "$name" codex --dangerously-bypass-approvals-and-sandbox
  fi
  if [ "$started" -eq 1 ]; then
    "$CONTAINER_CMD" stop "$name" >/dev/null 2>&1 &
  fi
}

run_cmd() {
  local name=""
  local image=""
  local openai=0
  local auth=0
  local temp=0
  local shell=0
  local cpu=""
  local mem=""

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --image) image="$2"; shift 2 ;;
      --openai) openai=1; shift ;;
      --auth) auth=1; shift ;;
      --temp) temp=1; shift ;;
      --shell) shell=1; shift ;;
      --cpu) cpu="$2"; shift 2 ;;
      --mem) mem="$2"; shift 2 ;;
      --help) usage_run; return 0 ;;
      *) die "Unknown option for run: $1" ;;
    esac
  done

  require_container

  if [ "$openai" -eq 1 ]; then
    [ -n "$image" ] || image="$DEFAULT_IMAGE"
    run_openai "$name" "$image" "$temp" "$shell" "$auth" "$cpu" "$mem"
    return 0
  fi

  [ -n "$image" ] || image="$DEFAULT_IMAGE"
  if [ -z "$name" ] && [ "$temp" -eq 0 ]; then
    name="$(default_name "$DEFAULT_NAME_PREFIX")"
  fi

  run_local "$name" "$image" "$temp" "$shell" "$cpu" "$mem"
}

auth_cmd() {
  local name=""
  local image="$DEFAULT_IMAGE"

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --image) image="$2"; shift 2 ;;
      --help) usage_auth; return 0 ;;
      *) die "Unknown option for auth: $1" ;;
    esac
  done

  require_container
  if [ -z "$name" ]; then
    name="$(default_name "$AUTH_NAME_PREFIX")"
  fi
  run_auth_flow "$image" "$name"
}

exec_cmd() {
  local name=""
  local openai=0
  local shell=0
  local cmd=()

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --openai) openai=1; shift ;;
      --shell) shell=1; shift ;;
      --help) usage_exec; return 0 ;;
      --) shift; cmd=("$@"); break ;;
      *) die "Unknown option for exec: $1" ;;
    esac
  done

  require_container

  if [ -z "$name" ]; then
    if [ "$openai" -eq 1 ]; then
      name="$(default_name "$OPENAI_NAME_PREFIX")"
    else
      name="$(default_name "$DEFAULT_NAME_PREFIX")"
    fi
  fi

  if [ "${#cmd[@]}" -eq 0 ]; then
    cmd=(bash)
  fi

  if ! container_running "$name"; then
    die "Container not running: $name"
  fi

  "$CONTAINER_CMD" exec -it "$name" "${cmd[@]}"
}

simple_name_cmd() {
  local action="$1"
  shift
  local name=""
  local openai=0

  while [ $# -gt 0 ]; do
    case "$1" in
      --name) name="$2"; shift 2 ;;
      --openai) openai=1; shift ;;
      --help) usage_simple_name; return 0 ;;
      *) die "Unknown option: $1" ;;
    esac
  done

  require_container

  if [ -z "$name" ]; then
    if [ "$openai" -eq 1 ]; then
      name="$(default_name "$OPENAI_NAME_PREFIX")"
    else
      name="$(default_name "$DEFAULT_NAME_PREFIX")"
    fi
  fi

  case "$action" in
    start) "$CONTAINER_CMD" start -i "$name" ;;
    stop) "$CONTAINER_CMD" stop "$name" ;;
    restart) "$CONTAINER_CMD" restart "$name" ;;
    rm) "$CONTAINER_CMD" rm "$name" ;;
    *) die "Unknown action: $action" ;;
  esac
}

ls_cmd() {
  require_container
  "$CONTAINER_CMD" ls -a
}

cmd="${1:-}"
case "$cmd" in
  build) shift; build_cmd "$@" ;;
  run) shift; run_cmd "$@" ;;
  auth) shift; auth_cmd "$@" ;;
  exec) shift; exec_cmd "$@" ;;
  start|stop|restart|rm) shift; simple_name_cmd "$cmd" "$@" ;;
  ls) shift; ls_cmd "$@" ;;
  --help|-h|help|"") usage ;;
  *) die "Unknown command: $cmd" ;;
esac
